package config

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

/*
FlagLoader implements a Loader type to parse settings from command line flags.

Command line flag names are generated by expanding the path for each setting
to a list of optional prefixes and ending with the setting's name:
	opts := struct {
		HTMLParser struct {
			ElementIDs []string
			Name       string
		}
	}{}
results in paths
	["HTMLParser", "ElementIDs"]
	["HTMLParser", "Name"]
Each element is then replaced with the result of passing it to SplitName:
	["HTML", "Parser", "Element", "IDs"]
	["HTML", "Parser", "Name"]
Any dashes in each word are removed, the words lowercased, and finally joined
with dashes to produce the final names:
	-html-parser-element-ids
	-html-parser-name

The zero value is ready to use.
*/
type FlagLoader struct {
	fs *flag.FlagSet
}

// Name returns the name of the loader. It is always "flag".
func (*FlagLoader) Name() string {
	return "flag"
}

/*
Init initializes the loader with the given settings.

Init must be called before Load.
*/
func (fl *FlagLoader) Init(settings []Setting) {
	fl.fs = flag.NewFlagSet(os.Args[0], flag.ContinueOnError)
	fl.fs.SetOutput(ioutil.Discard)
	for i := range settings {
		path := settings[i].Path
		name := fl.transformName(settings[i].Path)
		if fl.fs.Lookup(name) != nil {
			panic(fmt.Sprintf("duplicate flag name %s for %s", name, path))
		}
		help := settings[i].Tag.Get("help")
		fl.fs.Var(settings[i].Setter, name, help)
	}
}

/*
SetUsageFn sets a function to be executed to provide usage information.

If the -h flag is not overridden and is encountered on the command line when
fl.Load is called, the function provided will be called.

This method is called by (*Config).Load to provide detailed usage information
for all loaders.
*/
func (fl *FlagLoader) SetUsageFn(fn func()) {
	if fl.fs != nil {
		fl.fs.Usage = fn
	}
}

/*
Parse loads arguments from the provided slice.

It is similar to fl.Load except that arguments are provided instead of being
loaded from os.Args[1:]. It is useful primarily for testing.

The returned error, if non-nil, will be either ErrHelp or an error value
returned by (*flag.FlagSet).Parse.
*/
func (fl *FlagLoader) Parse(args []string) error {
	err := fl.fs.Parse(args)
	if err == flag.ErrHelp {
		return ErrHelp
	}
	return err
}

/*
Args returns any command-line arguments that are left after parsing arguments.

It returns nil if Load() has not been called.
*/
func (fl *FlagLoader) Args() []string {
	return fl.fs.Args()
}

/*
Load attempts to parse the configured settings from command line flags.

The returned error, if non-nil, will be either ErrHelp or an error value
returned by (*flag.FlagSet).Parse.
*/
func (fl *FlagLoader) Load() error {
	return fl.Parse(os.Args[1:])
}

// Usage returns a string with a list of command line flags and their descriptions.
func (fl *FlagLoader) Usage() string {
	var b strings.Builder
	b.WriteString("Command Line Flags:\n")
	if fl.fs != nil {
		fl.fs.VisitAll(func(f *flag.Flag) {
			b.WriteString("  -")
			b.WriteString(f.Name)
			ibf, ok := f.Value.(interface{ IsBoolFlag() bool })
			if !ok || !ibf.IsBoolFlag() {
				b.WriteString(" ")
				if getter, ok := f.Value.(flag.Getter); ok {
					b.WriteString(FriendlyTypeName(getter.Get()))
				} else {
					b.WriteString("value")
				}
			}
			usage := strings.Replace(f.Usage, "\n", "\n    \t", -1)
			z := isZeroValue(f.Value)
			if usage != "" || !z {
				b.WriteString("\n    \t")
				b.WriteString(usage)
				if !z {
					b.WriteString(" (default ")
					b.WriteString(f.Value.String())
					b.WriteString(")")
				}
			}
			b.WriteString("\n")
		})
	}
	return b.String()
}

func (fl *FlagLoader) transformName(path *Path) string {
	elements := path.Elements()
	for i := range elements {
		parts := SplitName(elements[i])
		for i := range parts {
			parts[i] = strings.Trim(strings.ToLower(parts[i]), "-_")
		}
		elements[i] = strings.Join(parts, "-")
	}
	return strings.Join(elements, "-")
}
